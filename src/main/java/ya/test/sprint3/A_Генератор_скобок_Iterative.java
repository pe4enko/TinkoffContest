package ya.test.sprint3;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Arrays;

/**
 * Рита по поручению Тимофея наводит порядок в правильных скобочных последовательностях (ПСП), состоящих только из
 * круглых скобок (). Для этого ей надо сгенерировать все ПСП длины 2n в алфавитном порядке —– алфавит состоит из ( и )
 * и открывающая скобка идёт раньше закрывающей.
 * <p>
 * Помогите Рите —– напишите программу, которая по заданному n выведет все ПСП в нужном порядке.
 * <p>
 * Рассмотрим второй пример. Надо вывести ПСП из четырёх символов. Таких всего две:
 * <p>
 * (()) ()() (()) идёт раньше ()(), так как первый символ у них одинаковый, а на второй позиции у первой ПСП стоит (,
 * который идёт раньше ). Формат ввода На вход функция принимает n — целое число от 0 до 10.
 * <p>
 * Формат вывода Функция должна напечатать все возможные скобочные последовательности заданной длины в алфавитном
 * (лексикографическом) порядке.
 */
public class A_Генератор_скобок_Iterative {

    public static void main(String[] args) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out))) {

            int n = readInt(reader);

            genParenthesis(n, writer);

            writer.flush();
        }
    }


    /**
     * Итеративный способ решения этой задачи: в этом случае идея будет принципиально другой — нужно ввести понятие
     * лексикографического порядка для скобочных последовательностей.
     * <p>
     * <p>
     * Все правильные скобочные последовательности для одного типа скобок можно упорядочить с учётом того, что
     * $'('<')'$. Например, для n=6 самой лексикографически младшей последовательностью будет $((()))$, а самой старшей
     * — $()()()$.
     * <p>
     * <p>
     * Чтобы получить следующую лексикографическую последовательность, нужно найти самую правую открывающуюся скобку,
     * перед которой стоит закрывающаяся, чтобы при их перестановке местами скобочная последовательность оставалась
     * правильной. Поменяем их местами и сделаем суффикс самым лексикографическим младшим — для этого нужно на каждом
     * шаге вычислять разницу между количеством скобок.
     * <p>
     * <p>
     * На мой взгляд, этот подход чуть муторнее рекурсивного, однако его можно использовать для решения других задач на
     * генерирование множеств. Реализуем это в коде.
     */
    private static void genParenthesis(int k, Writer writer) throws IOException {
        // количество скобок, должно быть четное
        int n = k * 2;

        char[] arr = new char[n];

        Arrays.fill(arr, 0, k, '(');
        Arrays.fill(arr, k, n, ')');

        writer.write(arr);
        writer.write("\n");

        while (true) {
            /* индекс, по которому кладем скобку в список */
            int ind = n - 1;

            /* разница между скобками
             cnt = 0 - кол-во открывающихся равно кол-ву закрывающихся
             cnt < 0 - кол-во закрывающихся больше кол-ва открывающихся
             cnt > 0 - кол-во открывающихся больше кол-ва закрывающихся
             */
            int cnt = 0;

            //находим откр. скобку, которую можно заменить
            //нужно найти самую правую открывающуюся скобку, перед которой стоит закрывающаяся,
            // чтобы при их перестановке местами скобочная последовательность оставалась правильной
            while (ind >= 0) {
                if (arr[ind] == ')') {
                    cnt--;
                }

                if (arr[ind] == '(') {
                    cnt++;
                }

                //если cnt < 0, то это означает, что справа с конца закрывающихся скобок больше чем открывающихся
                if (cnt < 0 && arr[ind] == '(') {
                    break;
                }

                ind--;
            }

            //ind - это позиция крайней правой скобки перед которой стоит закрывающаяся.

            //если не нашли, то алгоритм заканчивает работу
            if (ind < 0) {
                break;
            }

            //заменяем на закр. скобку
            arr[ind] = ')';

            //заменяем на самую лексикографическую минимальную
            for (int i = ind + 1; i < n; i++) {
                if (i <= (n - ind + cnt) / 2 + ind) { // todo: магия (((((((((((
                    arr[i] = '(';
                } else {
                    arr[i] = ')';
                }
            }

            writer.write(arr);
            writer.write("\n");
        }
    }

    private static int readInt(BufferedReader reader) throws IOException {
        return Integer.parseInt(reader.readLine());
    }
}
